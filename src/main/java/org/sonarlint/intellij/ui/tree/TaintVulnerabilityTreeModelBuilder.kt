/*
 * SonarLint for IntelliJ IDEA
 * Copyright (C) 2015-2021 SonarSource
 * sonarlint@sonarsource.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
 */
package org.sonarlint.intellij.ui.tree

import com.google.common.collect.ComparisonChain
import com.google.common.collect.ImmutableList
import com.google.common.collect.Ordering
import com.intellij.openapi.vfs.VirtualFile
import org.sonarlint.intellij.ui.nodes.AbstractNode
import org.sonarlint.intellij.ui.nodes.FileNode
import org.sonarlint.intellij.ui.nodes.IssueNode
import org.sonarlint.intellij.ui.nodes.LocalTaintVulnerabilityNode
import org.sonarlint.intellij.ui.nodes.SummaryNode
import org.sonarlint.intellij.issue.vulnerabilities.LocalTaintVulnerability
import java.util.Comparator
import java.util.TreeSet
import java.util.function.Consumer
import java.util.stream.Collectors
import javax.annotation.Nonnull
import javax.swing.tree.DefaultTreeModel

class TaintVulnerabilityTreeModelBuilder {

  private val issueComparator: Comparator<LocalTaintVulnerability> = LocalTaintVulnerabilityComparator()

  private val index = IssueTreeIndex()
  private val summary = SummaryNode()
  val model = DefaultTreeModel(summary)

  fun numberIssues() = summary.issueCount

  fun updateModel(map: Map<VirtualFile, Collection<LocalTaintVulnerability>>) {
    val toRemove = index.allFiles.stream().filter { f: VirtualFile? ->
      !map.containsKey(f)
    }.collect(Collectors.toList())
    toRemove.forEach(Consumer { file: VirtualFile -> removeFile(file) })
    for ((key, value) in map) {
      setFileIssues(key, value)
    }
    model.nodeChanged(summary)
  }

  private fun setFileIssues(file: VirtualFile, issues: Iterable<LocalTaintVulnerability>) {
    if (!accept(file)) {
      removeFile(file)
      return
    }
    if (issues.toList().isEmpty()) {
      removeFile(file)
      return
    }
    var newFile = false
    var fNode = index.getFileNode(file)
    if (fNode == null) {
      newFile = true
      fNode = FileNode(file)
      index.setFileNode(fNode)
    }
    setIssues(fNode, issues)
    if (newFile) {
      val parent = summary
      val idx = parent.getInsertIdx(fNode, FileNodeComparator())
      val newIdx = intArrayOf(idx)
      model.nodesWereInserted(parent, newIdx)
      model.nodeChanged(parent)
    } else {
      model.nodeStructureChanged(fNode)
    }
  }

  private fun removeFile(file: VirtualFile) {
    val node = index.getFileNode(file)
    if (node != null) {
      index.remove(node.file())
      model.removeNodeFromParent(node)
    }
  }

  private fun setIssues(node: FileNode, issuePointers: Iterable<LocalTaintVulnerability>) {
    node.removeAllChildren()

    // 15ms for 500 issues -> to improve?
    val set = TreeSet(issueComparator)
    for (issue in issuePointers) {
      set.add(issue)
    }
    for (issue in set) {
      val iNode = LocalTaintVulnerabilityNode(issue)
      node.add(iNode)
    }
  }

  private fun accept(file: VirtualFile): Boolean {
    return file.isValid
  }

  private class FileNodeComparator : Comparator<FileNode> {
    override fun compare(o1: FileNode, o2: FileNode): Int {
      val c = o1.file().name.compareTo(o2.file().name)
      return if (c != 0) {
        c
      } else o1.file().path.compareTo(o2.file().path)
    }
  }

  internal class LocalTaintVulnerabilityComparator : Comparator<LocalTaintVulnerability> {
    private val severityOrder: List<String> = ImmutableList.of("BLOCKER", "CRITICAL", "MAJOR", "MINOR", "INFO")

    override fun compare(@Nonnull o1: LocalTaintVulnerability, @Nonnull o2: LocalTaintVulnerability): Int {

      val dateCompare = o1.creationDate().compareTo(o2.creationDate())
      if (dateCompare != 0) {
        return dateCompare
      }
      val severityCompare = Ordering.explicit<String>(severityOrder).compare(o1.severity(), o2.severity())
      if (severityCompare != 0) {
        return severityCompare
      }

      val r1 = o1.rangeMarker()
      val r2 = o2.rangeMarker()

      val rangeStart1 = r1?.startOffset ?: -1
      val rangeStart2 = r2?.startOffset ?: -1
      return ComparisonChain.start()
        .compare(rangeStart1, rangeStart2)
        .compare(o1.ruleKey(), o2.ruleKey())
        .result()
    }
  }

  fun getNextIssue(startNode: AbstractNode): IssueNode? {
    if (startNode !is IssueNode) {
      return firstIssueDown(startNode)
    }
    val next = getNextNode(startNode)
      ?: // no next node in the entire tree
      return null
    return if (next is IssueNode) {
      next
    } else firstIssueDown(next)
  }

  fun getPreviousIssue(startNode: AbstractNode): IssueNode? {
    val next = getPreviousNode(startNode)
      ?: // no next node in the entire tree
      return null
    return if (next is IssueNode) {
      next
    } else lastIssueDown(next)
  }

  /**
   * Finds the first issue node which is child of a given node.
   */
  private fun firstIssueDown(node: AbstractNode): IssueNode? {
    if (node is IssueNode) {
      return node
    }
    if (node.childCount > 0) {
      val firstChild = node.firstChild
      return firstIssueDown(firstChild as AbstractNode)
    }
    return null
  }

  /**
   * Finds the first issue node which is child of a given node.
   */
  private fun lastIssueDown(node: AbstractNode): IssueNode? {
    if (node is IssueNode) {
      return node
    }
    val lastChild = node.lastChild ?: return null
    return lastIssueDown(lastChild as AbstractNode)
  }

  private fun getPreviousNode(startNode: AbstractNode): AbstractNode? {
    val parent = startNode.parent as AbstractNode?
      ?: return null
    val previous = parent.getChildBefore(startNode) ?: return getPreviousNode(parent)
    return previous as AbstractNode
  }

  /**
   * Next node, either the sibling if it exists, or the sibling of the parent
   */
  private fun getNextNode(startNode: AbstractNode): AbstractNode? {
    val parent = startNode.parent as AbstractNode?
      ?: return null
    val after = parent.getChildAfter(startNode) ?: return getNextNode(parent)
    return after as AbstractNode
  }

  companion object {
  }
}
